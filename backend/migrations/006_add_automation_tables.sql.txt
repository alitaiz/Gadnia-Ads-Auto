-- Drop existing tables if they exist to start fresh with the new structure.
-- This is acceptable for a development environment to apply a new schema.
DROP TABLE IF EXISTS automation_action_throttle;
DROP TABLE IF EXISTS automation_logs;
DROP TABLE IF EXISTS automation_rules;

-- Table to store flexible automation rules
CREATE TABLE IF NOT EXISTS automation_rules (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    rule_type VARCHAR(50) NOT NULL, -- e.g., 'BID_ADJUSTMENT', 'SEARCH_TERM_AUTOMATION'
    ad_type VARCHAR(10) NOT NULL DEFAULT 'SP', -- NEW: 'SP', 'SB', 'SD'
    
    -- Config contains all specific parameters for the rule, making the schema flexible.
    -- This now ALSO includes the frequency/schedule for the rule.
    -- e.g., { "conditionGroups": [...], "frequency": {"unit": "minutes", "value": 30} }
    config JSONB NOT NULL,
    
    -- Scope: Defines which campaigns this rule applies to.
    -- Storing as JSONB array of campaign IDs.
    -- e.g., '{"campaignIds": ["123", "456"]}'
    scope JSONB NOT NULL,
    
    profile_id TEXT NOT NULL, -- The profile this rule belongs to
    is_active BOOLEAN DEFAULT TRUE,
    last_run_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table to log all actions taken by the automation engine
CREATE TABLE IF NOT EXISTS automation_logs (
    id SERIAL PRIMARY KEY,
    rule_id INTEGER REFERENCES automation_rules(id) ON DELETE SET NULL,
    run_at TIMESTAMPTZ DEFAULT NOW(),
    status VARCHAR(50) NOT NULL, -- 'SUCCESS', 'FAILURE', 'NO_ACTION'
    summary TEXT, -- e.g., "Adjusted 5 keyword bids." or "No actions needed."
    details JSONB -- Detailed log, e.g., { changes: [{ keywordId: "...", oldBid: 1.0, newBid: 0.9 }] }
);

-- NEW TABLE: Tracks when an action was last taken on an entity for a rule.
-- This enforces a cooldown period to prevent rapid-fire changes.
CREATE TABLE IF NOT EXISTS automation_action_throttle (
    id SERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES automation_rules(id) ON DELETE CASCADE,
    entity_id TEXT NOT NULL, -- e.g., keyword ID, target ID, or search term text
    throttle_until TIMESTAMPTZ NOT NULL
);

-- A unique index to enforce one throttle per rule/entity combination for fast lookups.
CREATE UNIQUE INDEX IF NOT EXISTS idx_automation_throttle_unique ON automation_action_throttle (rule_id, entity_id);
-- An index on the expiration time for potential cleanup tasks.
CREATE INDEX IF NOT EXISTS idx_automation_throttle_expires ON automation_action_throttle (throttle_until);


-- Index for performance
CREATE INDEX IF NOT EXISTS idx_automation_rules_type ON automation_rules(rule_type);
CREATE INDEX IF NOT EXISTS idx_automation_rules_ad_type ON automation_rules(ad_type);
CREATE INDEX IF NOT EXISTS idx_automation_rules_active ON automation_rules(is_active);
CREATE INDEX IF NOT EXISTS idx_automation_logs_rule_id ON automation_logs(rule_id);
CREATE INDEX IF NOT EXISTS idx_automation_logs_run_at ON automation_logs(run_at);


-- Function and Trigger to update the 'updated_at' column automatically
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS set_timestamp_rules ON automation_rules;
CREATE TRIGGER set_timestamp_rules
BEFORE UPDATE ON automation_rules
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();


-- =============================================================================
-- Grant Permissions to Application User
-- =============================================================================
-- IMPORTANT: Replace 'gadnia' with the actual DB_USER from your .env file.
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE automation_rules, automation_logs, automation_action_throttle TO gadnia;
GRANT USAGE, SELECT ON SEQUENCE automation_rules_id_seq, automation_logs_id_seq, automation_action_throttle_id_seq TO gadnia;